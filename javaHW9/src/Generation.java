/**
 * @fileName Generation.java
 * @author Xingzi Guo (xingzig@andrew.cmu.edu)
 * @Andrew ID: xingzig
 * @Assignment: Homework 9-1 genetic programming
 * @date Last Modified: 11/17/2014
 * @description: In this assignment, we will generate 500 GPTrees and evolve 5 generation of trees. 
 */

/* Generated by Together */
import java.util.*;
import java.text.*;


/** A container of GPTrees. */
public class Generation {
    private int numTrees;
	private GPTree[] population;
	private double[] fitness;

    /**
     * Get the number of trees of this generation
     * 
     * @return the number of trees of this generation
     */
    public int getNumTrees() {
		return numTrees;
	}
    
    /**
     * set the new population to the old generation
     * 
     * @param population set the new population to the old generation
     */
    public void setPopulation(GPTree[] population) {
		this.population = population;
	}
    
    /** Specifies the number of GPTrees in this generation, the
    * factories used to generate the individual trees, the maximum tree depth,
    * and the Random object used. */
    Generation(int numTrees, OperatorFactory o, TerminalFactory t, int m, Random r) {
        this.numTrees = numTrees;
        population = new GPTree[numTrees];
        fitness = new double[numTrees];
        for (int i = 0; i < numTrees; i++)
            population[i] = new GPTree(o, t, m, r);
    }
    
	Generation(int n) {
		numTrees = n;
		population = new GPTree[numTrees];
		fitness = new double[numTrees];
	}

    /** Evaluate each tree in this generation, and set each tree's fitness value. */
    public void evalAll(DataSet d) {
        for (int i = 0; i < numTrees; i++)
            fitness[i] = 1 / population[i].eval(d); //slightly change in evalAll
    }

    /** Print the symbolicEval of each tree, and its fitness value. Very lengthy! */
    public void printAll() {
        for (int i = 0; i < numTrees; i++) {
            System.out.println(population[i]);
            System.out.println("This tree's fitness is "
                +  NumberFormat.getInstance().format(population[i].getFitness()));
        }
    }

    /** Prints the tree with the lowest fitness value. */
    public void printBestTree() {
        Arrays.sort(population);
        //printAll();
        System.out.println(population[0]);
        System.out.println("Its fitness is " + population[0].getFitness());
    }
    
    /**
     * calculate the proportion of choosing each tree according to thier fitness
     * 
     * @param r A specific tree will be chosen when random number r fall into its proportion
     * @return the chosen tree
     */
    public GPTree chooseTreeProportionalToFitness(Random r){
    	double lower = 0;
    	double upper = 0; //to sum up all fitness.
    	double[] sumpre = new double[numTrees];
    	sumpre[0] = fitness[0];
    	
    	for (int i = 0; i < numTrees; i++){
    		upper += fitness[i];
    	}  	
    	double randNum = r.nextDouble() * (upper - lower);
    	
    	for (int i = 1; i < numTrees; i++){
    		sumpre[i] = sumpre[i-1] + fitness[i];
    	}
    	return population[chooseRandTreeByProportional(sumpre,randNum)];
    }
   
    /**
     * This method determines which tree to choose
     * 
     * @param proportion sum of former propotion to each tree
     * @param r A specific tree will be chosen when random number r fall into its proportion
     * @return the index of the chosen tree
     */
    private int chooseRandTreeByProportional(double[] proportion, double r){
    	if (r >= 0 && r <= proportion[0])
    		return 0;
    	for (int i = 1; i < numTrees; i++){
    		if (r > proportion[i-1] && r <= proportion[i]){
    			return i;
    		}
    	}
    	return -1;
    }
    
}
